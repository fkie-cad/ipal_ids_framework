import itertools

import orjson

import ipal_iids.settings as settings
from combiner.combiner import Combiner


class HeuristicCombiner(Combiner):
    _name = "Heuristic"
    _description = "This combiner implements a heuristic that minimizes the number of misclassifications, which maximizes accuracy."
    _requires_training = True
    _heuristic_default_settings = {"tie-breaker": False}

    def __init__(self):
        super().__init__()
        self._add_default_settings(self._heuristic_default_settings)

        self.model = None
        self.keys = None

    def _get_input_order(self):
        # All possible inputs that can be generated by the IDSs (count: 2^len(idss)).
        # Sequentialized into a list.
        return list(itertools.product([0, 1], repeat=len(self.keys)))

    def _get_activations(self, alerts):
        if not set(alerts.keys()) == set(self.keys):
            settings.logger.error("Keys of combiner do not match alerts")
            settings.logger.error(f"- data keys: {','.join(alerts.keys())}")
            settings.logger.error(f"- combiner keys: {','.join(self.keys)}")
            exit(1)

        return [int(alerts[ids]) for ids in self.keys]

    def train(self, file):
        self.model = {}

        settings.logger.info("Loading combiner training file and fitting combiner")
        with self._open_file(file, "r") as f:
            for line in f:
                js = orjson.loads(line)

                if self.keys is None:
                    self.keys = sorted(js["scores"].keys())
                    self.model = {input: [0, 0] for input in self._get_input_order()}

                # Count heuristic
                vector = tuple(self._get_activations(js["alerts"]))
                malicious = int(js["malicious"] is not False)
                self.model[vector][malicious] += 1

    def combine(self, alerts, scores):
        vector = tuple(self._get_activations(alerts))
        benign = self.model[vector][0]
        malicious = self.model[vector][1]

        if benign == 0 and malicious == 0:
            return self.settings["tie-breaker"], 1, 0
        elif benign == malicious:
            return self.settings["tie-breaker"], malicious / (benign + malicious), 0
        else:
            return malicious > benign, malicious / (benign + malicious), 0

    def save_trained_model(self):
        if self.settings["model-file"] is None:
            return False

        model = {
            "_name": self._name,
            "settings": self.settings,
            "keys": self.keys,
            "model": list(self.model.items()),
        }

        with self._open_file(self._resolve_model_file_path(), mode="wb") as f:
            f.write(
                orjson.dumps(
                    model, option=orjson.OPT_INDENT_2 | orjson.OPT_APPEND_NEWLINE
                )
            )

        return True

    def load_trained_model(self):
        if self.settings["model-file"] is None:
            return False

        try:  # Open model file
            with self._open_file(self._resolve_model_file_path(), mode="rb") as f:
                model = orjson.loads(f.read())
        except FileNotFoundError:
            settings.logger.info(
                f"Model file {str(self._resolve_model_file_path())} not found."
            )
            return False

        # Load model
        assert self._name == model["_name"]
        self.settings = model["settings"]
        self.keys = model["keys"]
        self.model = {tuple(k): v for k, v in model["model"]}

        return True
